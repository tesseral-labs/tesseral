// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries-common.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const bumpSessionLastActiveTime = `-- name: BumpSessionLastActiveTime :exec
UPDATE
    sessions
SET
    last_active_time = now()
WHERE
    id = $1
`

func (q *Queries) BumpSessionLastActiveTime(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, bumpSessionLastActiveTime, id)
	return err
}

const getCurrentSessionSigningKeyByProjectID = `-- name: GetCurrentSessionSigningKeyByProjectID :one
SELECT
    id, project_id, public_key, private_key_cipher_text, create_time, expire_time
FROM
    session_signing_keys
WHERE
    project_id = $1
ORDER BY
    create_time DESC
LIMIT 1
`

func (q *Queries) GetCurrentSessionSigningKeyByProjectID(ctx context.Context, projectID uuid.UUID) (SessionSigningKey, error) {
	row := q.db.QueryRow(ctx, getCurrentSessionSigningKeyByProjectID, projectID)
	var i SessionSigningKey
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.PublicKey,
		&i.PrivateKeyCipherText,
		&i.CreateTime,
		&i.ExpireTime,
	)
	return i, err
}

const getImpersonatorUserByID = `-- name: GetImpersonatorUserByID :one
SELECT
    id,
    email
FROM
    users
WHERE
    id = $1
`

type GetImpersonatorUserByIDRow struct {
	ID    uuid.UUID
	Email string
}

func (q *Queries) GetImpersonatorUserByID(ctx context.Context, id uuid.UUID) (GetImpersonatorUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getImpersonatorUserByID, id)
	var i GetImpersonatorUserByIDRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const getProjectIDByCustomAuthDomain = `-- name: GetProjectIDByCustomAuthDomain :one
SELECT
    id
FROM
    projects
WHERE
    custom_auth_domain = $1
    OR auth_domain = $1
`

func (q *Queries) GetProjectIDByCustomAuthDomain(ctx context.Context, customAuthDomain *string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getProjectIDByCustomAuthDomain, customAuthDomain)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getSessionDetailsByRefreshTokenSHA256 = `-- name: GetSessionDetailsByRefreshTokenSHA256 :one
SELECT
    sessions.id AS session_id,
    users.id AS user_id,
    users.email AS user_email,
    organizations.id AS organization_id,
    organizations.display_name AS organization_display_name,
    organizations.project_id AS project_id,
    sessions.impersonator_user_id
FROM
    sessions
    JOIN users ON sessions.user_id = users.id
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    sessions.refresh_token_sha256 = $1
`

type GetSessionDetailsByRefreshTokenSHA256Row struct {
	SessionID               uuid.UUID
	UserID                  uuid.UUID
	UserEmail               string
	OrganizationID          uuid.UUID
	OrganizationDisplayName string
	ProjectID               uuid.UUID
	ImpersonatorUserID      *uuid.UUID
}

func (q *Queries) GetSessionDetailsByRefreshTokenSHA256(ctx context.Context, refreshTokenSha256 []byte) (GetSessionDetailsByRefreshTokenSHA256Row, error) {
	row := q.db.QueryRow(ctx, getSessionDetailsByRefreshTokenSHA256, refreshTokenSha256)
	var i GetSessionDetailsByRefreshTokenSHA256Row
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.UserEmail,
		&i.OrganizationID,
		&i.OrganizationDisplayName,
		&i.ProjectID,
		&i.ImpersonatorUserID,
	)
	return i, err
}
