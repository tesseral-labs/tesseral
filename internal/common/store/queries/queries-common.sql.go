// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-common.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const bumpSessionLastActiveTime = `-- name: BumpSessionLastActiveTime :exec
UPDATE
    sessions
SET
    last_active_time = now()
WHERE
    id = $1
`

func (q *Queries) BumpSessionLastActiveTime(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, bumpSessionLastActiveTime, id)
	return err
}

const getCurrentSessionSigningKeyByProjectID = `-- name: GetCurrentSessionSigningKeyByProjectID :one
SELECT
    id, project_id, public_key, private_key_cipher_text, create_time, expire_time
FROM
    session_signing_keys
WHERE
    project_id = $1
ORDER BY
    create_time DESC
LIMIT 1
`

func (q *Queries) GetCurrentSessionSigningKeyByProjectID(ctx context.Context, projectID uuid.UUID) (SessionSigningKey, error) {
	row := q.db.QueryRow(ctx, getCurrentSessionSigningKeyByProjectID, projectID)
	var i SessionSigningKey
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.PublicKey,
		&i.PrivateKeyCipherText,
		&i.CreateTime,
		&i.ExpireTime,
	)
	return i, err
}

const getImpersonatorUserByID = `-- name: GetImpersonatorUserByID :one
SELECT
    id,
    email
FROM
    users
WHERE
    id = $1
`

type GetImpersonatorUserByIDRow struct {
	ID    uuid.UUID
	Email string
}

func (q *Queries) GetImpersonatorUserByID(ctx context.Context, id uuid.UUID) (GetImpersonatorUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getImpersonatorUserByID, id)
	var i GetImpersonatorUserByIDRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const getProjectActions = `-- name: GetProjectActions :many
SELECT
    name
FROM
    actions
WHERE
    project_id = $1
`

func (q *Queries) GetProjectActions(ctx context.Context, projectID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getProjectActions, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectCookieDomainByProjectID = `-- name: GetProjectCookieDomainByProjectID :one
SELECT
    cookie_domain
FROM
    projects
WHERE
    id = $1
`

func (q *Queries) GetProjectCookieDomainByProjectID(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getProjectCookieDomainByProjectID, id)
	var cookie_domain string
	err := row.Scan(&cookie_domain)
	return cookie_domain, err
}

const getProjectIDByVaultDomain = `-- name: GetProjectIDByVaultDomain :one
SELECT
    id
FROM
    projects
WHERE
    vault_domain = $1
`

func (q *Queries) GetProjectIDByVaultDomain(ctx context.Context, vaultDomain string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getProjectIDByVaultDomain, vaultDomain)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getProjectTrustedDomains = `-- name: GetProjectTrustedDomains :many
SELECT
    project_trusted_domains.domain
FROM
    project_trusted_domains
WHERE
    project_id = $1
`

func (q *Queries) GetProjectTrustedDomains(ctx context.Context, projectID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getProjectTrustedDomains, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var domain string
		if err := rows.Scan(&domain); err != nil {
			return nil, err
		}
		items = append(items, domain)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionDetailsByRefreshTokenSHA256 = `-- name: GetSessionDetailsByRefreshTokenSHA256 :one
SELECT
    sessions.id AS session_id,
    users.is_owner AS user_is_owner,
    users.id AS user_id,
    users.email AS user_email,
    users.display_name AS user_display_name,
    users.profile_picture_url AS user_profile_picture_url,
    organizations.id AS organization_id,
    organizations.display_name AS organization_display_name,
    sessions.impersonator_user_id
FROM
    sessions
    JOIN users ON sessions.user_id = users.id
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    sessions.refresh_token_sha256 = $1
    AND organizations.project_id = $2
`

type GetSessionDetailsByRefreshTokenSHA256Params struct {
	RefreshTokenSha256 []byte
	ProjectID          uuid.UUID
}

type GetSessionDetailsByRefreshTokenSHA256Row struct {
	SessionID               uuid.UUID
	UserIsOwner             bool
	UserID                  uuid.UUID
	UserEmail               string
	UserDisplayName         *string
	UserProfilePictureUrl   *string
	OrganizationID          uuid.UUID
	OrganizationDisplayName string
	ImpersonatorUserID      *uuid.UUID
}

func (q *Queries) GetSessionDetailsByRefreshTokenSHA256(ctx context.Context, arg GetSessionDetailsByRefreshTokenSHA256Params) (GetSessionDetailsByRefreshTokenSHA256Row, error) {
	row := q.db.QueryRow(ctx, getSessionDetailsByRefreshTokenSHA256, arg.RefreshTokenSha256, arg.ProjectID)
	var i GetSessionDetailsByRefreshTokenSHA256Row
	err := row.Scan(
		&i.SessionID,
		&i.UserIsOwner,
		&i.UserID,
		&i.UserEmail,
		&i.UserDisplayName,
		&i.UserProfilePictureUrl,
		&i.OrganizationID,
		&i.OrganizationDisplayName,
		&i.ImpersonatorUserID,
	)
	return i, err
}

const getSessionDetailsByRelayedSessionRefreshTokenSHA256 = `-- name: GetSessionDetailsByRelayedSessionRefreshTokenSHA256 :one
SELECT
    sessions.id AS session_id,
    users.id AS user_id,
    users.is_owner AS user_is_owner,
    users.email AS user_email,
    users.display_name AS user_display_name,
    users.profile_picture_url AS user_profile_picture_url,
    organizations.id AS organization_id,
    organizations.display_name AS organization_display_name,
    sessions.impersonator_user_id
FROM
    relayed_sessions
    JOIN sessions ON relayed_sessions.session_id = sessions.id
    JOIN users ON sessions.user_id = users.id
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    relayed_sessions.relayed_refresh_token_sha256 = $1
    AND organizations.project_id = $2
`

type GetSessionDetailsByRelayedSessionRefreshTokenSHA256Params struct {
	RelayedRefreshTokenSha256 []byte
	ProjectID                 uuid.UUID
}

type GetSessionDetailsByRelayedSessionRefreshTokenSHA256Row struct {
	SessionID               uuid.UUID
	UserID                  uuid.UUID
	UserIsOwner             bool
	UserEmail               string
	UserDisplayName         *string
	UserProfilePictureUrl   *string
	OrganizationID          uuid.UUID
	OrganizationDisplayName string
	ImpersonatorUserID      *uuid.UUID
}

func (q *Queries) GetSessionDetailsByRelayedSessionRefreshTokenSHA256(ctx context.Context, arg GetSessionDetailsByRelayedSessionRefreshTokenSHA256Params) (GetSessionDetailsByRelayedSessionRefreshTokenSHA256Row, error) {
	row := q.db.QueryRow(ctx, getSessionDetailsByRelayedSessionRefreshTokenSHA256, arg.RelayedRefreshTokenSha256, arg.ProjectID)
	var i GetSessionDetailsByRelayedSessionRefreshTokenSHA256Row
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.UserIsOwner,
		&i.UserEmail,
		&i.UserDisplayName,
		&i.UserProfilePictureUrl,
		&i.OrganizationID,
		&i.OrganizationDisplayName,
		&i.ImpersonatorUserID,
	)
	return i, err
}

const getUserActions = `-- name: GetUserActions :many
SELECT DISTINCT
    (actions.name)
FROM
    users
    JOIN user_role_assignments ON users.id = user_role_assignments.user_id
    JOIN roles ON user_role_assignments.role_id = roles.id
    JOIN role_actions ON roles.id = role_actions.role_id
    JOIN actions ON role_actions.action_id = actions.id
WHERE
    user_id = $1
`

func (q *Queries) GetUserActions(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserActions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
