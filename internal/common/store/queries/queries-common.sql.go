// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-common.sql

package queries

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const bumpSessionLastActiveTime = `-- name: BumpSessionLastActiveTime :exec
UPDATE
    sessions
SET
    last_active_time = now()
WHERE
    id = $1
`

func (q *Queries) BumpSessionLastActiveTime(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, bumpSessionLastActiveTime, id)
	return err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT
    api_keys.id, organization_id, api_keys.display_name, secret_token_sha256, secret_token_suffix, expire_time, api_keys.create_time, api_keys.update_time, organizations.id, project_id, organizations.display_name, scim_enabled, organizations.create_time, organizations.update_time, logins_disabled, log_in_with_google, log_in_with_microsoft, log_in_with_password, log_in_with_authenticator_app, log_in_with_passkey, require_mfa, log_in_with_email, log_in_with_saml, custom_roles_enabled, log_in_with_github, api_keys_enabled
FROM
    api_keys
    JOIN organizations ON api_keys.organization_id = organization.id
WHERE
    api_keys.id = $1
    AND organizations.project_id = $2
`

type GetAPIKeyByIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetAPIKeyByIDRow struct {
	ID                        uuid.UUID
	OrganizationID            uuid.UUID
	DisplayName               string
	SecretTokenSha256         []byte
	SecretTokenSuffix         *string
	ExpireTime                *time.Time
	CreateTime                *time.Time
	UpdateTime                *time.Time
	ID_2                      uuid.UUID
	ProjectID                 uuid.UUID
	DisplayName_2             string
	ScimEnabled               bool
	CreateTime_2              *time.Time
	UpdateTime_2              *time.Time
	LoginsDisabled            bool
	LogInWithGoogle           bool
	LogInWithMicrosoft        bool
	LogInWithPassword         bool
	LogInWithAuthenticatorApp bool
	LogInWithPasskey          bool
	RequireMfa                bool
	LogInWithEmail            bool
	LogInWithSaml             bool
	CustomRolesEnabled        bool
	LogInWithGithub           bool
	ApiKeysEnabled            bool
}

func (q *Queries) GetAPIKeyByID(ctx context.Context, arg GetAPIKeyByIDParams) (GetAPIKeyByIDRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByID, arg.ID, arg.ProjectID)
	var i GetAPIKeyByIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.DisplayName,
		&i.SecretTokenSha256,
		&i.SecretTokenSuffix,
		&i.ExpireTime,
		&i.CreateTime,
		&i.UpdateTime,
		&i.ID_2,
		&i.ProjectID,
		&i.DisplayName_2,
		&i.ScimEnabled,
		&i.CreateTime_2,
		&i.UpdateTime_2,
		&i.LoginsDisabled,
		&i.LogInWithGoogle,
		&i.LogInWithMicrosoft,
		&i.LogInWithPassword,
		&i.LogInWithAuthenticatorApp,
		&i.LogInWithPasskey,
		&i.RequireMfa,
		&i.LogInWithEmail,
		&i.LogInWithSaml,
		&i.CustomRolesEnabled,
		&i.LogInWithGithub,
		&i.ApiKeysEnabled,
	)
	return i, err
}

const getCurrentSessionSigningKeyByProjectID = `-- name: GetCurrentSessionSigningKeyByProjectID :one
SELECT
    id, project_id, public_key, private_key_cipher_text, create_time, expire_time
FROM
    session_signing_keys
WHERE
    project_id = $1
ORDER BY
    create_time DESC
LIMIT 1
`

func (q *Queries) GetCurrentSessionSigningKeyByProjectID(ctx context.Context, projectID uuid.UUID) (SessionSigningKey, error) {
	row := q.db.QueryRow(ctx, getCurrentSessionSigningKeyByProjectID, projectID)
	var i SessionSigningKey
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.PublicKey,
		&i.PrivateKeyCipherText,
		&i.CreateTime,
		&i.ExpireTime,
	)
	return i, err
}

const getImpersonatorUserByID = `-- name: GetImpersonatorUserByID :one
SELECT
    id,
    email
FROM
    users
WHERE
    id = $1
`

type GetImpersonatorUserByIDRow struct {
	ID    uuid.UUID
	Email string
}

func (q *Queries) GetImpersonatorUserByID(ctx context.Context, id uuid.UUID) (GetImpersonatorUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getImpersonatorUserByID, id)
	var i GetImpersonatorUserByIDRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const getOrganizationByProjectIDAndID = `-- name: GetOrganizationByProjectIDAndID :one
SELECT
    id, project_id, display_name, scim_enabled, create_time, update_time, logins_disabled, log_in_with_google, log_in_with_microsoft, log_in_with_password, log_in_with_authenticator_app, log_in_with_passkey, require_mfa, log_in_with_email, log_in_with_saml, custom_roles_enabled, log_in_with_github, api_keys_enabled
FROM
    organizations
WHERE
    id = $1
    AND project_id = $2
`

type GetOrganizationByProjectIDAndIDParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) GetOrganizationByProjectIDAndID(ctx context.Context, arg GetOrganizationByProjectIDAndIDParams) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByProjectIDAndID, arg.ID, arg.ProjectID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.DisplayName,
		&i.ScimEnabled,
		&i.CreateTime,
		&i.UpdateTime,
		&i.LoginsDisabled,
		&i.LogInWithGoogle,
		&i.LogInWithMicrosoft,
		&i.LogInWithPassword,
		&i.LogInWithAuthenticatorApp,
		&i.LogInWithPasskey,
		&i.RequireMfa,
		&i.LogInWithEmail,
		&i.LogInWithSaml,
		&i.CustomRolesEnabled,
		&i.LogInWithGithub,
		&i.ApiKeysEnabled,
	)
	return i, err
}

const getProjectActions = `-- name: GetProjectActions :many
SELECT
    name
FROM
    actions
WHERE
    project_id = $1
`

func (q *Queries) GetProjectActions(ctx context.Context, projectID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getProjectActions, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectCookieDomainByProjectID = `-- name: GetProjectCookieDomainByProjectID :one
SELECT
    cookie_domain
FROM
    projects
WHERE
    id = $1
`

func (q *Queries) GetProjectCookieDomainByProjectID(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getProjectCookieDomainByProjectID, id)
	var cookie_domain string
	err := row.Scan(&cookie_domain)
	return cookie_domain, err
}

const getProjectIDByVaultDomain = `-- name: GetProjectIDByVaultDomain :one
SELECT
    id
FROM
    projects
WHERE
    vault_domain = $1
`

func (q *Queries) GetProjectIDByVaultDomain(ctx context.Context, vaultDomain string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getProjectIDByVaultDomain, vaultDomain)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getProjectTrustedDomains = `-- name: GetProjectTrustedDomains :many
SELECT
    project_trusted_domains.domain
FROM
    project_trusted_domains
WHERE
    project_id = $1
`

func (q *Queries) GetProjectTrustedDomains(ctx context.Context, projectID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getProjectTrustedDomains, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var domain string
		if err := rows.Scan(&domain); err != nil {
			return nil, err
		}
		items = append(items, domain)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT
    sessions.id, user_id, sessions.create_time, expire_time, refresh_token_sha256, impersonator_user_id, last_active_time, primary_auth_factor, users.id, organization_id, password_bcrypt, google_user_id, microsoft_user_id, email, users.create_time, users.update_time, deactivate_time, is_owner, failed_password_attempts, password_lockout_expire_time, authenticator_app_secret_ciphertext, failed_authenticator_app_attempts, authenticator_app_lockout_expire_time, authenticator_app_recovery_code_sha256s, users.display_name, profile_picture_url, github_user_id, organizations.id, project_id, organizations.display_name, scim_enabled, organizations.create_time, organizations.update_time, logins_disabled, log_in_with_google, log_in_with_microsoft, log_in_with_password, log_in_with_authenticator_app, log_in_with_passkey, require_mfa, log_in_with_email, log_in_with_saml, custom_roles_enabled, log_in_with_github, api_keys_enabled
FROM
    sessions
    JOIN users ON sessions.user_id = users.id
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    sessions.id = $1
    AND organizations.project_id = $2
`

type GetSessionParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetSessionRow struct {
	ID                                  uuid.UUID
	UserID                              uuid.UUID
	CreateTime                          *time.Time
	ExpireTime                          *time.Time
	RefreshTokenSha256                  []byte
	ImpersonatorUserID                  *uuid.UUID
	LastActiveTime                      *time.Time
	PrimaryAuthFactor                   PrimaryAuthFactor
	ID_2                                uuid.UUID
	OrganizationID                      uuid.UUID
	PasswordBcrypt                      *string
	GoogleUserID                        *string
	MicrosoftUserID                     *string
	Email                               string
	CreateTime_2                        *time.Time
	UpdateTime                          *time.Time
	DeactivateTime                      *time.Time
	IsOwner                             bool
	FailedPasswordAttempts              int32
	PasswordLockoutExpireTime           *time.Time
	AuthenticatorAppSecretCiphertext    []byte
	FailedAuthenticatorAppAttempts      int32
	AuthenticatorAppLockoutExpireTime   *time.Time
	AuthenticatorAppRecoveryCodeSha256s [][]byte
	DisplayName                         *string
	ProfilePictureUrl                   *string
	GithubUserID                        *string
	ID_3                                uuid.UUID
	ProjectID                           uuid.UUID
	DisplayName_2                       string
	ScimEnabled                         bool
	CreateTime_3                        *time.Time
	UpdateTime_2                        *time.Time
	LoginsDisabled                      bool
	LogInWithGoogle                     bool
	LogInWithMicrosoft                  bool
	LogInWithPassword                   bool
	LogInWithAuthenticatorApp           bool
	LogInWithPasskey                    bool
	RequireMfa                          bool
	LogInWithEmail                      bool
	LogInWithSaml                       bool
	CustomRolesEnabled                  bool
	LogInWithGithub                     bool
	ApiKeysEnabled                      bool
}

func (q *Queries) GetSession(ctx context.Context, arg GetSessionParams) (GetSessionRow, error) {
	row := q.db.QueryRow(ctx, getSession, arg.ID, arg.ProjectID)
	var i GetSessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreateTime,
		&i.ExpireTime,
		&i.RefreshTokenSha256,
		&i.ImpersonatorUserID,
		&i.LastActiveTime,
		&i.PrimaryAuthFactor,
		&i.ID_2,
		&i.OrganizationID,
		&i.PasswordBcrypt,
		&i.GoogleUserID,
		&i.MicrosoftUserID,
		&i.Email,
		&i.CreateTime_2,
		&i.UpdateTime,
		&i.DeactivateTime,
		&i.IsOwner,
		&i.FailedPasswordAttempts,
		&i.PasswordLockoutExpireTime,
		&i.AuthenticatorAppSecretCiphertext,
		&i.FailedAuthenticatorAppAttempts,
		&i.AuthenticatorAppLockoutExpireTime,
		&i.AuthenticatorAppRecoveryCodeSha256s,
		&i.DisplayName,
		&i.ProfilePictureUrl,
		&i.GithubUserID,
		&i.ID_3,
		&i.ProjectID,
		&i.DisplayName_2,
		&i.ScimEnabled,
		&i.CreateTime_3,
		&i.UpdateTime_2,
		&i.LoginsDisabled,
		&i.LogInWithGoogle,
		&i.LogInWithMicrosoft,
		&i.LogInWithPassword,
		&i.LogInWithAuthenticatorApp,
		&i.LogInWithPasskey,
		&i.RequireMfa,
		&i.LogInWithEmail,
		&i.LogInWithSaml,
		&i.CustomRolesEnabled,
		&i.LogInWithGithub,
		&i.ApiKeysEnabled,
	)
	return i, err
}

const getSessionDetailsByRefreshTokenSHA256 = `-- name: GetSessionDetailsByRefreshTokenSHA256 :one
SELECT
    sessions.id AS session_id,
    users.is_owner AS user_is_owner,
    users.id AS user_id,
    users.email AS user_email,
    users.display_name AS user_display_name,
    users.profile_picture_url AS user_profile_picture_url,
    organizations.id AS organization_id,
    organizations.display_name AS organization_display_name,
    organizations.project_id AS project_id,
    sessions.impersonator_user_id
FROM
    sessions
    JOIN users ON sessions.user_id = users.id
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    sessions.refresh_token_sha256 = $1
`

type GetSessionDetailsByRefreshTokenSHA256Row struct {
	SessionID               uuid.UUID
	UserIsOwner             bool
	UserID                  uuid.UUID
	UserEmail               string
	UserDisplayName         *string
	UserProfilePictureUrl   *string
	OrganizationID          uuid.UUID
	OrganizationDisplayName string
	ProjectID               uuid.UUID
	ImpersonatorUserID      *uuid.UUID
}

func (q *Queries) GetSessionDetailsByRefreshTokenSHA256(ctx context.Context, refreshTokenSha256 []byte) (GetSessionDetailsByRefreshTokenSHA256Row, error) {
	row := q.db.QueryRow(ctx, getSessionDetailsByRefreshTokenSHA256, refreshTokenSha256)
	var i GetSessionDetailsByRefreshTokenSHA256Row
	err := row.Scan(
		&i.SessionID,
		&i.UserIsOwner,
		&i.UserID,
		&i.UserEmail,
		&i.UserDisplayName,
		&i.UserProfilePictureUrl,
		&i.OrganizationID,
		&i.OrganizationDisplayName,
		&i.ProjectID,
		&i.ImpersonatorUserID,
	)
	return i, err
}

const getSessionDetailsByRelayedSessionRefreshTokenSHA256 = `-- name: GetSessionDetailsByRelayedSessionRefreshTokenSHA256 :one
SELECT
    sessions.id AS session_id,
    users.id AS user_id,
    users.is_owner AS user_is_owner,
    users.email AS user_email,
    users.display_name AS user_display_name,
    users.profile_picture_url AS user_profile_picture_url,
    organizations.id AS organization_id,
    organizations.display_name AS organization_display_name,
    organizations.project_id AS project_id,
    sessions.impersonator_user_id
FROM
    relayed_sessions
    JOIN sessions ON relayed_sessions.session_id = sessions.id
    JOIN users ON sessions.user_id = users.id
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    relayed_sessions.relayed_refresh_token_sha256 = $1
`

type GetSessionDetailsByRelayedSessionRefreshTokenSHA256Row struct {
	SessionID               uuid.UUID
	UserID                  uuid.UUID
	UserIsOwner             bool
	UserEmail               string
	UserDisplayName         *string
	UserProfilePictureUrl   *string
	OrganizationID          uuid.UUID
	OrganizationDisplayName string
	ProjectID               uuid.UUID
	ImpersonatorUserID      *uuid.UUID
}

func (q *Queries) GetSessionDetailsByRelayedSessionRefreshTokenSHA256(ctx context.Context, relayedRefreshTokenSha256 []byte) (GetSessionDetailsByRelayedSessionRefreshTokenSHA256Row, error) {
	row := q.db.QueryRow(ctx, getSessionDetailsByRelayedSessionRefreshTokenSHA256, relayedRefreshTokenSha256)
	var i GetSessionDetailsByRelayedSessionRefreshTokenSHA256Row
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.UserIsOwner,
		&i.UserEmail,
		&i.UserDisplayName,
		&i.UserProfilePictureUrl,
		&i.OrganizationID,
		&i.OrganizationDisplayName,
		&i.ProjectID,
		&i.ImpersonatorUserID,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT
    users.id, organization_id, password_bcrypt, google_user_id, microsoft_user_id, email, users.create_time, users.update_time, deactivate_time, is_owner, failed_password_attempts, password_lockout_expire_time, authenticator_app_secret_ciphertext, failed_authenticator_app_attempts, authenticator_app_lockout_expire_time, authenticator_app_recovery_code_sha256s, users.display_name, profile_picture_url, github_user_id, organizations.id, project_id, organizations.display_name, scim_enabled, organizations.create_time, organizations.update_time, logins_disabled, log_in_with_google, log_in_with_microsoft, log_in_with_password, log_in_with_authenticator_app, log_in_with_passkey, require_mfa, log_in_with_email, log_in_with_saml, custom_roles_enabled, log_in_with_github, api_keys_enabled
FROM
    users
    JOIN organizations ON users.organization_id = organizations.id
WHERE
    users.id = $1
    AND organizations.project_id = $2
`

type GetUserParams struct {
	ID        uuid.UUID
	ProjectID uuid.UUID
}

type GetUserRow struct {
	ID                                  uuid.UUID
	OrganizationID                      uuid.UUID
	PasswordBcrypt                      *string
	GoogleUserID                        *string
	MicrosoftUserID                     *string
	Email                               string
	CreateTime                          *time.Time
	UpdateTime                          *time.Time
	DeactivateTime                      *time.Time
	IsOwner                             bool
	FailedPasswordAttempts              int32
	PasswordLockoutExpireTime           *time.Time
	AuthenticatorAppSecretCiphertext    []byte
	FailedAuthenticatorAppAttempts      int32
	AuthenticatorAppLockoutExpireTime   *time.Time
	AuthenticatorAppRecoveryCodeSha256s [][]byte
	DisplayName                         *string
	ProfilePictureUrl                   *string
	GithubUserID                        *string
	ID_2                                uuid.UUID
	ProjectID                           uuid.UUID
	DisplayName_2                       string
	ScimEnabled                         bool
	CreateTime_2                        *time.Time
	UpdateTime_2                        *time.Time
	LoginsDisabled                      bool
	LogInWithGoogle                     bool
	LogInWithMicrosoft                  bool
	LogInWithPassword                   bool
	LogInWithAuthenticatorApp           bool
	LogInWithPasskey                    bool
	RequireMfa                          bool
	LogInWithEmail                      bool
	LogInWithSaml                       bool
	CustomRolesEnabled                  bool
	LogInWithGithub                     bool
	ApiKeysEnabled                      bool
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, arg.ID, arg.ProjectID)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.PasswordBcrypt,
		&i.GoogleUserID,
		&i.MicrosoftUserID,
		&i.Email,
		&i.CreateTime,
		&i.UpdateTime,
		&i.DeactivateTime,
		&i.IsOwner,
		&i.FailedPasswordAttempts,
		&i.PasswordLockoutExpireTime,
		&i.AuthenticatorAppSecretCiphertext,
		&i.FailedAuthenticatorAppAttempts,
		&i.AuthenticatorAppLockoutExpireTime,
		&i.AuthenticatorAppRecoveryCodeSha256s,
		&i.DisplayName,
		&i.ProfilePictureUrl,
		&i.GithubUserID,
		&i.ID_2,
		&i.ProjectID,
		&i.DisplayName_2,
		&i.ScimEnabled,
		&i.CreateTime_2,
		&i.UpdateTime_2,
		&i.LoginsDisabled,
		&i.LogInWithGoogle,
		&i.LogInWithMicrosoft,
		&i.LogInWithPassword,
		&i.LogInWithAuthenticatorApp,
		&i.LogInWithPasskey,
		&i.RequireMfa,
		&i.LogInWithEmail,
		&i.LogInWithSaml,
		&i.CustomRolesEnabled,
		&i.LogInWithGithub,
		&i.ApiKeysEnabled,
	)
	return i, err
}

const getUserActions = `-- name: GetUserActions :many
SELECT DISTINCT
    (actions.name)
FROM
    users
    JOIN user_role_assignments ON users.id = user_role_assignments.user_id
    JOIN roles ON user_role_assignments.role_id = roles.id
    JOIN role_actions ON roles.id = role_actions.role_id
    JOIN actions ON role_actions.action_id = actions.id
WHERE
    user_id = $1
`

func (q *Queries) GetUserActions(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserActions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
